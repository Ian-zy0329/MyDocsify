## JVM组成
1. 类加载器
2. 运行时数据区
3. 本地方法接口
4. 执行引擎

类加载器将字节码（class文件）加载到JVM内存即运行时数据区中，字节码是JVM指令集规范，不能直接交给底层操作系统去执行，需要通过特定的命令解析器执行引擎
将字节码翻译成底层操作系统指令再交给cpu去执行，而这个过程需要调用其他语言的接口则通过本地方法接口来实现。

## 类加载器
负责加载class文件
加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的：
1. BootStrap ClassLoader：rt.
2. jarExtension ClassLoader: 加载扩展的 jar 包
3. App ClassLoader：指定的 classpath 下面的 jar 包
4. Custom ClassLoader：自定义的类加载器

### 类加载的流程
从类加载到虚拟机内存开始，到释放内存总共有七个步骤：加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析统称为连接。

## 双亲委派模型
当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。
双亲委派模型的执行流程：
- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常。

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。
如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Obj
                                                                                                                                                                                                                                                                                                                                                                                                                       
 ### 打破双亲委派模型方法
自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。

## 运行时数据区域
>- 介绍下 Java 内存区域（运行时数据区）
>- Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
>- 对象的访问定位的两种方式（句柄和直接指针两种方式）

线程私有的：
- 程序计数器：1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了
- 虚拟机栈：除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的，方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
  - 栈帧：局部变量表、操作数栈、动态链接、方法返回地址
- 本地方法栈：本地方法栈则为虚拟机使用到的 Native 方法服务

线程共享的：
- 堆：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。
  1. 新生代内存(Young Generation)
  2. 老年代(Old Generation)
  3. 永久代(Permanent Generation)
- 方法区：方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
  - 方法区和永久代以及元空间是什么关系呢？久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。
  - 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
    - 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
    - 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了
    - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
- 直接内存 (非运行时数据区的一部分)：直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的

### 字符串常量池
字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。

JDK 1.7 为什么要将字符串常量池移动到堆中？
主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存
                  
## HotSpot 虚拟机对象
### 对象的创建
1. 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程
2. 分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存，分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
   - 内存分配并发问题：如何内存分配过程的线程安全性？如果两个线程先后把对象引用指向了同一个内存区域，怎么办？虚拟机采用两种方式来保证线程安全
     1. CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
     2. HotSpot 虚拟机中采用的，这种方案被称之为 TLAB 分配： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
3. 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值
4. 设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中
5. 执行 init 方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来

### 对象的内存布局
在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
对象头包括两部分信息：
- 标记字段（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等
- 类型指针（Klass Word）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容

### 对象的访问定位的两种方式
对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。
- 句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
- 直接指针：如果使用直接指针访问，reference 中存储的直接就是对象的地址。

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

## JVM垃圾回收
> - 如何判断对象是否死亡（两种方法）。
> - 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
> - 如何判断一个常量是废弃常量如何判断一个类是无用的类垃圾收集有哪些算法，各自的特点？
> - HotSpot 为什么要分为新生代和老年代？
> - 常见的垃圾回收器有哪些？
> - 介绍一下 CMS,G1 收集器。
> - Minor Gc 和 Full GC 有什么不同呢？
                                 
### 内存分配和回收原则
#### 对象优先在 Eden 区分配
大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

#### 大对象直接进入老年代            
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。
                            
#### 长期存活的对象将进入老年代
虚拟机给每个对象一个对象年龄（Age）计数器。
大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。
对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：    
- 部分收集 (Partial GC)：
  - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
  - 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
  - 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

- 整堆收集 (Full GC)：收集整个 Java 堆和方法区

### 死亡对象判断方法
#### 引用计数法
给对象中添加一个引用计数器：
1. 每当有一个地方引用它，计数器就加 1；
2. 当引用失效，计数器就减 1；
3. 任何时候计数器为 0 的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题    
#### 可达性分析算法
这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

### 引用类型总结
1. 强引用（StrongReference）：如果一个对象具有强引用，垃圾回收器绝不会回收它
2. 软引用（SoftReference）：如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存
3. 弱引用（WeakReference）：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。如果一个对象只具有弱引用，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
4. 虚引用（PhantomReference）：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。
     
### 如何判断一个常量是废弃常量？
如果没有任何对象引用一个常量的话，就说明这个常量是废弃常量。如果此时发生内存回收且有必要的话，这个常量就会被系统清理。

### 如何判断一个类是无用的类？
1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法
#### 标记-清除算法 
标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

这种垃圾收集算法会带来两个明显的问题：
1. 效率问题：标记和清除两个过程效率都不高。
2. 空间问题：标记清除后会产生大量不连续的内存碎片。

#### 复制算法
为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
      
虽然改进了标记-清除算法，但依然存在下面这些问题：
- 可用内存变小：可用内存缩小为原来的一半。
- 不适合老年代：如果存活对象数量比较大，复制性能会变得很差

#### 标记-整理算法
标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景       
#### 分代收集算法
当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。                            

#### HotSpot 为什么要分为新生代和老年代？ 
因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。

### 垃圾收集器
JDK 默认垃圾收集器（使用 java -XX:+PrintCommandLineFlags -version 命令查看）：
- JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1

#### Serial 收集器/Serial Old 收集器（Serial 收集器的老年代版本）
Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。
新生代采用标记-复制算法，老年代采用标记-整理算法。
简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择
>java虚拟机有两种模式，分别为Client模式和Server模式，Server启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用优化，在服务器环境中最大化程序执行速度而设计；Client启动快速，内存占用少，编译快，针对桌面应用程序优化，为在客户端环境中减少启动时间而优化；
#### ParNew 收集器
ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。
新生代采用标记-复制算法，老年代采用标记-整理算法。    
并行和并发概念补充：
- 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

#### Parallel Scavenge 收集器/Parallel Old 收集器（Parallel Scavenge 收集器的老年代版本）
Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。
新生代采用标记-复制算法，老年代采用标记-整理算法。

#### CMS 收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作

CMS 收集器是一种 “标记-清除”算法实现的，整个过程分为四个步骤：
- 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

主要优点：并发收集、低停顿，缺点：对 CPU 资源敏感、无法处理浮动垃圾、它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生

#### G1 收集器
G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.

它具备以下特点：
- 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- 空间整合：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。
 
G1 收集器的运作大致分为以下几个步骤：初始标记、并发标记、最终标记、筛选回收

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。

#### ZGC 收集器
与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进

ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。

## 重要的JVM参数
- 堆内存–Xms和-Xmx：'-Xms2G -Xmx5G'
- 新生代内存：
  1. '-XX:NewSize=256m''-XX:MaxNewSize=1024m'
  2. '-Xmn256m'
- 指定永久代/元空间的大小：'-XX:MetaspaceSize=N''-XX:MaxMetaspaceSize=N'  无论 -XX:MetaspaceSize 配置什么值，Metaspace 的初始容量都是 21807104（约 20.8m），MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用
- 垃圾回收器：
  1. '-XX:+UseSerialGC'：串行垃圾收集器（Serial 收集器）
  2. '-XX:+UseParallelGC'：并行垃圾收集器（Parallel Scavenge 收集器）
  3. '-XX:+UseConcMarkSweepGC'：CMS 垃圾收集器
  4. '-XX:+UseG1GC'：G1 垃圾收集器
- GC 日志记录：
  - '-XX:+PrintGCDetails'-XX:+PrintGCDateStamps'：必选，打印基本 GC 信息
  - '-XX:+PrintTenuringDistribution'：打印对象分布
  - '-XX:+PrintHeapAtGC'：打印堆数据
  - '-XX:+PrintReferenceGC'：打印Reference处理信息
  - '-XX:+PrintGCApplicationStoppedTime'：打印STW（stop the world）时间
  - '-XX:+PrintSafepointStatistics''-XX:PrintSafepointStatisticsCount=1'：打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
  - '-Xloggc:/path/to/gc-%t.log'：GC日志输出的文件路径
  - '-XX:+UseGCLogFileRotation'：开启日志文件分割
  - '-XX:NumberOfGCLogFiles=14'：最多分割几个文件，超过之后从头文件开始写
  - '-XX:GCLogFileSize=50M'：每个文件上限大小，超过就触发分割
- 处理 OOM：JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏
  - '-XX:+HeapDumpOnOutOfMemoryError'：指示 JVM 在遇到 OutOfMemoryError 错误时将 heap 转储到物理文件中
  - '-XX:HeapDumpPath=./java_pid<pid>.hprof'：表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <pid> 标记，则当前进程的进程 id 将附加到文件名中，并使用.hprof格式
  - '-XX:OnOutOfMemoryError="< cmd args >;< cmd args >"'：用于发出紧急命令，以便在内存不足的情况下执行; 应该在 cmd args 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: -XX:OnOutOfMemoryError="shutdown -r"
  - '-XX:+UseGCOverheadLimit'：是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例                            
- 其他
  - '-server'：启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM 
  - '-XX:+UseStringDeduplication'：Java 8u20 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 char [] 数组来优化堆内存。
  - '-XX:+UseLWPSynchronization'：设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步
  - '-XX:LargePageSizeInBytes'：设置用于 Java 堆的较大页面大小
  - '-XX:MaxHeapFreeRatio'：设置 GC 后, 堆空闲的最大百分比，以避免收缩。
  - '-XX:SurvivorRatio'：eden/survivor 空间的比例, 例如-XX:SurvivorRatio=6 设置每个 survivor 和 eden 之间的比例为 1:6
  - '-XX:+UseLargePages'：如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。
  - '-XX:+UseStringCache'：启用 String 池中可用的常用分配字符串的缓存。
  - '-XX:+UseCompressedStrings'：对 String 对象使用 byte [] 类型，该类型可以用纯 ASCII 格式表示
  - '-XX:+OptimizeStringConcat'：它尽可能优化字符串串联操作

## JVM 调优           


## JVM 逃逸分析
逃逸分析可以判断对象的使用范围，从而决定是否在堆中分配内存

一种典型的对象逃逸就是：对象被复制给成员变量或者静态变量，可能被外部使用，此时变量就发生了逃逸。
另一种典型的场景就是：对象通过return语句返回。如果对象通过return语句返回了，此时的程序并不能确定这个对象后续会不会被使用，外部的线程可以访问到这个变量，此时对象也发生了逃逸。

同步消除（锁消除）
栈内存分配
标量替换