## Redis持久化
> 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据
1. 快照（RDB文件）
> RDB持久化产生的文件是一个经过压缩的二进制文件，这个文件可以被保存到硬盘中，可以通过这个文件还原数据库的状态
- 工作原理
    - 进行RDB时，redis的主进程不会做io操作，会fork一个子进程来完成该操作
    - Redis 调用forks,子进程将数据集写入到一个临时 RDB 文件中
    - 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件
- 触发机制
  - 主动触发：
    1. save命令是同步的命令，会占用主进程，会造成阻塞，阻塞所有客户端的请求 
    2. bgsave是异步进行，进行持久化的时候，redis还可以将继续响应客户端请求
  - 自动触发：
    1. save自动触发配置，时间策略   save m n m秒内修改n次key，触发rdb
    2. 从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发bgsave命令
    3. 执行flushall命令，会触发rdb
    4. 退出redis，且没有开启aof时
> 特点：
> 1. RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件 
> 2. 与 AOF 格式的文件相比，RDB 文件可以更快的重启 
> 3. 因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据

2. 追加式文件（AOF文件）
> 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来 

- AOF配置项
  - appendonly no（默认不开启aof  而是使用rdb的方式）
  - appendfsync always（每次修改都会sync 消耗性能）、appendfsync everysec（每秒执行一次 sync 可能会丢失这一秒的数据）、appendfsync no（不执行 sync ,这时候操作系统自己同步数据，速度最快）
> AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是appendfsync everysec 配置，会有1s损耗），第二步是对aof文件的重写

随着Redis的运行，AOF的日志会越来越长，如果实例宕机重启，那么重放整个AOF将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr一千次，那么就不需要去记录这1000次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写
- AOF 重写机制
    - Redis 提供了bgrewriteaof指令用于对AOF日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的AOF文件
    - redis.config中对重写机制的触发进行配置：通过将no-appendfsync-on-rewrite设置为yes，开启重写机制；auto-aof-rewrite-percentage 100意为比上次从写后文件大小增长了100%再次触发重写；auto-aof-rewrite-min-size 64mb意为当文件至少要达到64mb才会触发制动重写
> 特点：
> 1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次 2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题 3. AOF 机制的 rewrite 模式 4. AOF 文件比 RDB 文件大，且恢复速度慢 5. 数据集大的时候，比 rdb 启动效率低

## 缓存穿透
> 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求
- 解决方案
  1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
  2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
  3. 布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
## 缓存击穿
> 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）
- 解决方案
  1. 设置热点数据永远不过期
  2. 加写回操作加互斥锁，查询失败默认值快速返回
  3. 缓存预热
## 缓存雪崩
> 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库
- 解决方案
  1. Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃；
  2. 本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死；
  3. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生；
  4. 逻辑上永不过期给每一个缓存数据增加相应的缓存标记，缓存标记失效则更新数据缓存；
  5. 多级缓存，失效时通过二级更新一级，由第三方插件更新二级缓存；
## redis失效策略
内存淘汰策略：
1. 全局的键空间选择性移除
   - noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用）
   - allkeys-lru：在键空间中，移除最近最少使用的key。（缓存常用）
   - allkeys-random：在键空间中，随机移除某个key。
2. 设置过期时间的键空间选择性移除
   - volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key
   - volatile-random：在设置了过期时间的键空间中，随机移除某个key
   - volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除
缓存失效策略：
1. 定时清除：针对每个设置过期时间的key都创建指定定时器
2. 惰性清除：访问时判断，对内存不友好
3. 定时扫描清除：定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除

## redis读写模式
- CacheAside旁路缓存：写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存。延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后
> 如果没有专门的存储服务，同时是对数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务，适合使用 Cache Aside 模式
- Read/Write Though（读写穿透）：先查询缓存中数据是否存在,如果存在则直接返回,如果不存在,则由缓存组件负责从数据库中同步加载数据。 先查询要写入的数据在缓存中是否已经存在,如果已经存在,则更新缓存中的数据，并且由缓存组件同步更新到数据库中
> 用户读操作较多.相较于Cache aside而言更适合缓存一致的场景
- Write Behind Caching（异步缓存写入）：写只更新缓存，缓存服务异步更新DB，读miss后由缓存服务加载+写cache
> 写性能最高，定期异步刷新，存在数据丢失概率，适合写频率超高，需要合并，比如对一些计数业务，一条 Feed 被点赞 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据

## 数据不一致