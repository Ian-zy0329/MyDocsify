# redis四种部署模式对比
## 单点模式
就是默认配置，单个 Master 节点

优点：除了简单还是简单，配置简单，操作简单

缺点：1. 单点故障或宕机会导致服务不可用，数据丢失 2. 单点存储和算力受单个服务器限制

在谈解决办法以及其他模式前，先了解一下 AKF 拆分原则
### AKF拆分原则
AKF拆分原则是用于系统架构设计的指导原则，旨在帮助架构师和开发人员将系统拆分为更小、更易管理的组件，从而提高系统的扩展性、可维护性和灵活性。AKF拆分原则基于 AKF扩展立方体模型（X、Y、Z轴扩展），通过应用这些原则，可以有效地解决系统在扩展过程中遇到的性能瓶颈、复杂性增加等问题。
#### AKF拆分原则的核心思想：
AKF拆分原则的核心在于按业务功能、数据、和请求的特点，将系统合理拆分为多个相对独立的模块或服务，每个模块或服务可以独立扩展、部署和维护。这些原则帮助开发人员识别出系统中的可拆分点，并指导如何进行有效的拆分。
#### 主要拆分原则：
##### 1. 按请求类型拆分（X轴拆分）
* 原则：将相同功能的多个实例进行水平复制，通过负载均衡将请求分发到不同的实例上。这种拆分主要是通过增加更多的实例来处理更高的并发请求量。
* 应用场景：适用于无状态的服务或相同逻辑处理的服务，通过增加实例数量来应对更多的请求。
* 示例：一个Web服务器集群可以通过增加Web服务器实例来处理更多的用户请求，每个实例都是相同的。
##### 2. 按功能模块拆分（Y轴拆分）
* 原则：根据系统的不同功能模块，将其拆分为多个独立的服务或组件。每个服务或组件专注于处理一种特定的功能。
* 应用场景：适用于单体应用向微服务架构的转化，通过将系统按功能划分，降低耦合度，提高系统灵活性和可维护性。
* 示例：一个电商系统可以拆分为用户管理服务、订单处理服务、商品管理服务、支付服务等。
##### 3. 按数据范围拆分（Z轴拆分）
* 原则：将数据按某种逻辑（如按用户、地区、时间等）划分为多个分片（shard），不同的分片可以分布在不同的数据库实例或服务器上。
* 应用场景：适用于系统中存在大量数据需要处理，单个数据库或服务无法承受的情况，通过数据分片来分散负载。
* 示例：一个社交平台可以根据用户ID对用户数据进行分片，不同的用户分片存储在不同的数据库实例中，从而提升系统的扩展性。
#### 结合拆分原则的综合应用：
* 横向拆分（X轴）：通过增加相同服务的实例数量来扩展系统的处理能力。
* 功能拆分（Y轴）：通过将系统按功能模块拆分，降低系统复杂度，提高扩展性。
* 数据拆分（Z轴）：通过数据分片处理更大数据量的请求，提升系统的整体性能。
#### AKF拆分原则的适用场景：
1. 性能瓶颈：当系统的某一部分成为性能瓶颈时，应用AKF拆分原则可以将该部分拆分出来，独立扩展。
2. 系统复杂度增加：当系统变得过于复杂时，通过拆分降低各个部分的耦合度，使得每个部分更容易理解、维护和扩展。
3. 业务增长：随着业务的增长，系统的负载需求增加，通过拆分将系统扩展到多个服务器或数据中心。
#### 例子：
假设你在管理一个电商平台，随着用户和交易量的增长，单一的系统结构难以支撑业务扩展。你可以使用AKF拆分原则：

1. Y轴拆分：将系统拆分为用户服务、商品服务、订单服务、支付服务等独立服务。
2. Z轴拆分：对用户数据进行分片，按地理位置或用户ID将数据分布在多个数据库实例中。
3. X轴拆分：增加商品服务的实例数量，通过负载均衡分发请求，确保商品服务能够处理更高的并发量。
### 总结
AKF拆分原则为系统的扩展提供了清晰的指导，通过合理的拆分，可以降低系统复杂度，提升扩展性和可靠性，满足不断增长的业务需求。这些原则在微服务架构、分布式系统设计等领域具有广泛的应用。

### 单机问题解决
AKF 说白了还是通过增加硬件机器来解决单机的容量和单点可用性问题，只不过根据 AKF 可以从三个方向进行扩展

1. X轴解决了单点故障问题，每一台机器都有着相同的数据，其中一台挂掉马上切换到另一台；
2. Y轴解决了资源受限问题，按照功能划分的数据分拆到不同的机器上，减轻了每台机器的资源存储压力；
3. Z轴解决了访问压力问题，将业务数据再细分导向规则化的不同的机器，使得每台机器收到的并发访问压力就会大大减少。

而 redis 另外三种模式也可以看作是基于 AKF 拆分原则实现 redis 的高性能高可用高并发
## 主从模式
从一台Redis服务器的数据（主节点master），复制到其他Redis服务器（从节点slave）。数据复制单向，只能由主节点到从节点，master可读可写，slave只可读不可写；默认每台Redis服务器都是主节点，从节点需要在配置文件中单独配置，才会从默认的主节点变成从节点。一个主节点可以有0个或多个从节点，但每个从节点只能有一个主节点。

### 复制机制
* slave第一次连接master，一定会执行一次全量复制
* 全量复制数据量过大，会造成很大的网络开销，消耗CPU/内存/硬盘IO
* 增量复制用于处理在主从复制中因网络等数据丢失的场景，当slave再次连接上master，并且就是原来的master，如果条件允许，master补发数据给slave，补发数据量小，避免全量复制的开销（到底能不能复制还要看offset和buffer的情况）
* 如果slave再次连上的master是新选举的master，那么只能进行全量复制
* 早期的redis只有全量复制，增量复制是对全量复制的重大优化，尽量采用2.8以上版本
#### 全量同步
* slave给master发一个sync同步命令
* master通过bgsave命令fork子进程，持久化生成RDB文件
* master通过网络将RDB文件传给slave
* slave清空老数据，载入新的RDB文件，此时slave阻塞，无法响应客户端，专心复制
#### 增量同步
* 主从节点各自维护自己的复制偏移量offset，主节点写入命令时，offset=offset+命令字节长度；从节点收到主节点命令也会相应增加自己的offset，并同步给主节点。主节点同时维护自己的offset和从节点的offset，以此来判断主从节点数据是否一致。
* 主节点指令记录在本地buffer（缓冲区），异步将buffer同步给从节点
* 若网络不好，同步速度慢了，buffer满了就会从头开始覆盖前面的内容，于是无法增量复制，必须全量复制
### 主要作用
1. 数据冗余：热备份，持久化另一种方式
2. 故障恢复：master宕机，快速升级slave为master
3. 读写分离：master写，slave，提高服务器负载能力，同时可以根据需求添加slave
4. 负载均衡：配合读写分离，读多写少场景，多个slave分担负载，大大提高并发
5. 高可用基石：是实现哨兵和集群的基础
### 总结
优点很明显提高了系统的可用性，对比单点，主节点挂了可以把从节点升级为主节点，缺点也很明显，需要手动升级，于是就有了哨兵，而且存在数据冗余，主节点和从节点数据是一样的，浪费了宝贵的内存，

所以主从模式主要从 AKF 原则的 X 轴进行横向拆分，解决单点故障导致系统不可以，提升了系统的可用性
## 哨兵模式（Sentinel）
哨兵模式解决了从节点升级为主节点需要人工干预这一问题，当主节点挂了后，哨兵会自动在从节点中推选一个从节点升级为主节点。

### 哨兵的作用
哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的redis机器发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

* 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器;
* 当哨兵监测到master宕机，会自动将slave切换到master，然后通过发布订阅模式通过其他的从服务器，修改配置文件，让它们切换主机;
* 然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
### 哨兵模式的工作
#### 定时监控
* 每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最近的拓扑结构，可以感知新加入或故障转移的Redis数据节点
* 每隔2秒，每个Sentinel节点会与其他Sentinel节点通信，可以发现新的Sentinel节点，并与其他Sentinel节点交换对主节点的判断信息，方便故障转移及选举
* 每隔1秒，每个Sentinel节点会向主节点、从节点以及其他的Sentinel节点发送ping做一次心跳检测，来确认这些节点是否可达，实现对每个节点的监控

#### 主观下线和客观下线
- 主观下线：当Sentinel节点ping其他节点，超时未回复，Sentinel节点就会对该节点做失败判定。主观下线是当前Sentinel节点的一家之言，存在误判可能
- 客观下线：当Sentinel主观下线的节点是master，该Sentinel会询问其他Sentinel对master的判断，当大部分Sentinel都对master的下线做了同意判断，那么这个判断就是比较客观的

假设master宕机，sentinel 1先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的master，仅仅是sentinel 1主观的认为master不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由sentinel 1发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。
#### Sentinel集群的领导者选举
Sentinel节点已经对master做了客观下线，但还不能立刻进行故障转移，因为故障转移工作只需要一个Sentinel节点来完成，因此在Sentinel集群中要选出一个leader来进行故障转移。

Redis使用了Raft算法实现领导者选举：
* 每个在线的Sentinel节点都有资格成为领导者，他要求其他节点来投自己一票
* 先收到谁的要求就给谁投票，但不能给自己投
* 首先拿到大多数（即一半+1）的票当选领导者
#### 故障转移
Sentinel集群领导者负责此次故障转移
1. 排除主观下线的从节点
2. 选择优先级高的从节点，如果没有再进行3
3. 选择复制偏移量最大的从节点（复制的最完整），如果没有再进行4
4. 选择runid最小的从节点

### 哨兵模式的优缺点
#### 优点
* 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
* 主从可以自动切换，系统更健壮，可用性更高。
#### 缺点
* 具有主从模式的缺点，每台机器上的数据是一样的，内存的可用性较低。
* master挂了，切换新的master会造成未来得及主从同步的数据丢失
* 主从全量同步仍然要耗费大量时间
* Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。
## 集群模式（Cluster）