# 10月（编程题、多线程、贪心、动规、排序）
## 10月3日（快排、归并、菜鸟笔试）
### 快排
快速排序通过选取一个基准值（pivot），将待排序数组划分为两部分：一部分的元素都小于基准值，另一部分的元素都大于基准值。然后对这两部分递归进行排序。
```java
package top.ian.es;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/2 13:04
 */
public class QuickSort {

    public static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }

    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }

        swap(arr, i + 1, right);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {9, 7, 5, 11, 12, 2, 14, 3, 10, 6};
        quickSort(arr, 0, arr.length - 1);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```
### 归并
```java
package top.ian.es;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/2 13:40
 */
public class MergeSort {

    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        while (j <= right) {
            temp[k++] = arr[j++];
        }

        for (k = 0; k < temp.length; k++) {
            arr[left + k] = temp[k];
        }
    }

    public static void main(String[] args) {
        int[] arr = {9, 7, 5, 11, 12, 2, 14, 3, 10, 6};
        mergeSort(arr, 0, arr.length - 1);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }

}
```
### 菜鸟笔试
1. 编程实现：线程A向队列Q中不停写入数据，线程B从队列Q中不停读取数据（只要Q中有数据）。
```java
package top.ian.es;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 1:29
 */
public class ThreadTest {

    private static BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);

    public static void main(String[] args) {
        Thread a = new Thread(() -> {
            int i = 0;
            while (true) {
                try {
                    queue.put(i);
                    System.out.println("a：" + i);
                    i++;
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        Thread b = new Thread(() -> {
            while (true) {
                Integer i = null;
                try {
                    i = queue.take();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("b：" + i);
            }
        });

        a.start();
        b.start();
    }
}
```
2. 假如一个学校有x名学生，对全校同学进行一次测验，总分750分，现在需要对全校同学的分数进行分段统计，每y分为1个分数段，
   要求：用一条SQL语句统计出每个分数段有多少人。(y>=1, y<=750)
```sql
select 
    CONCAT(FLOOR(score / @y) * @y,'-',FLOOR(scor / @y) * @y + @y -1) AS score_range,
    COUNT(*) AS student_count
FROM
    student
GROUP BY 
    FLOOR(score / @y)
ORDER BY 
    FLOOR(score / @y);
```
3. 某停车场(Parklot)有停车位(ParkingSpace)若干：
   有多个入口和多个出口，入口完成扫描计时，出口完成结账及车位释放。
   停车位包含两类：货车位和小车位，货车按每小时10元计价，每天最高累计120元，小车位按每小时5元计价，每天最高累计60元。
   请注意提示剩余车位信息。
   为该停车场设计一个管理系统，还原该场景，功能包括：
   （1）车辆进入处理；
   （2）车辆离开处理；
   （3）计算当日停车场缴费总金额、单个车辆离场缴费额。
   (请考虑并发等相关的实际问题)
   设计停车场管理系统时，我们需要将题目中的实际需求转化为合理的设计思路和技术实现。这个过程可以通过分析问题的各个部分，并结合面向对象编程（OOP）和并发处理的知识来进行。下面是设计思路的形成过程，以及如何一步步将需求转化为系统设计：

### 1. **明确需求**
题目要求包括以下几个功能：
- **车辆进入处理**：车辆进入停车场后，需要找到一个可用的车位，记录进入时间。
- **车辆离开处理**：车辆离开时需要释放车位，并计算停车费用。
- **计算单车缴费**：根据停车时长和车辆类型计算缴费（货车和小车不同）。
- **计算总收入**：计算当日停车场的总收入。
- **剩余车位提示**：需要实时提示停车场中剩余的车位数量。
- **并发处理**：多个入口和出口同时操作，因此需要处理并发，保证系统数据一致性。

### 2. **分析实体与功能**
根据需求，系统中有多个核心实体和功能可以提取出来：
- **车辆（Vehicle）**：每辆车有不同的类型（货车或小车），车辆有车牌号等标识信息。
- **停车位（ParkingSpace）**：停车位分为货车位和小车位，每个车位有不同的占用状态。
- **停车场（ParkLot）**：管理多个车位、车辆进出、以及收费的核心类。它需要知道所有停车位的状态。
- **停车票（ParkingTicket）**：记录车辆进入停车场的时间和停放的车位，便于结算。
- **并发性**：停车场存在多个入口和出口，车辆进出需要并发处理，防止不同线程对停车位状态的冲突。

### 3. **确定设计思路（面向对象设计）**
根据需求，我们可以采用**面向对象编程（OOP）**的设计方法，将每一个实体和功能抽象为类，并让类之间合理交互：

#### 核心类设计：
1. **`Vehicle` 类**：抽象出车辆对象，车辆具有类型（货车、小车）和车牌号。
   - **属性**：车牌号、车辆类型。
   - **行为**：车辆可以进入和离开停车场。

2. **`ParkingSpace` 类**：抽象出停车位，分为小车位和货车位。
   - **属性**：车位类型（小车位、货车位）、是否被占用、关联的车辆。
   - **行为**：停车位可以被占用或释放。

3. **`ParkingTicket` 类**：用于记录停车信息，如进入时间、停车位信息等。
   - **属性**：车辆、停车位、进入时间。
   - **行为**：记录停车时间。

4. **`ParkLot` 类**：停车场类，是整个系统的管理类，管理停车位的分配和回收，计算停车费，统计总收入。
   - **属性**：所有停车位、所有活动的停车票、总收入。
   - **行为**：
      - **车辆进入**：找到空车位，并生成停车票。
      - **车辆离开**：根据停车票计算费用，释放车位，统计收入。
      - **查看剩余车位**：打印剩余车位数。
      - **并发处理**：使用 `Lock` 确保多个线程操作停车位时的数据一致性。

#### 并发设计：
为了处理多个线程（入口和出口）同时操作车位，必须确保线程安全。可以通过以下方式：
- 使用 `ReentrantLock` 来确保停车位操作的原子性，避免多线程同时修改同一停车位的状态。
- 每次进入停车场时加锁操作，确保只有一个线程可以修改停车位的占用状态。

### 4. **详细设计细化**
#### 车辆进入：
- 车辆进入时，首先判断是货车还是小车，然后寻找相应类型的空车位。
- 一旦找到空车位，将该车位标记为占用，并生成停车票。
- 在并发情况下，通过 `Lock` 来确保同一时刻只能有一个线程为车分配车位。

#### 车辆离开：
- 车辆离开时，基于停车票中的进入时间计算停车时长。
- 根据停车时长和车辆类型计算费用。
- 将车位标记为可用，更新停车场的总收入。

#### 费用计算：
- 通过 `Duration` 计算车辆的停车时长，然后使用 `Math.ceil()` 实现向上取整的计费方式。
- 货车按每小时 10 元，封顶 120 元；小车按每小时 5 元，封顶 60 元。

### 5. **实现系统扩展性**
- **可扩展性**：如果以后需要支持其他类型的车位或收费规则，可以在现有的结构上扩展，例如增加更多的 `VehicleType`，修改 `ParkingSpace` 的属性，或在 `ParkLot` 中增加更多的计算规则。
- **线程安全性**：通过锁机制保证了系统在并发环境下的安全性，可以保证多个入口和出口不会出现车位分配的冲突。
- **灵活性**：系统设计成模块化，便于维护和扩展。

### 总结：设计思路的演进
1. **需求分析**：首先了解停车场的核心功能，包括车辆进出、车位分配、收费计算等。
2. **面向对象分析**：提取问题中的实体，抽象成类，明确每个类的职责。
3. **并发问题解决**：为了解决多线程并发访问停车位的问题，使用 `Lock` 保证线程安全。
4. **算法细化**：具体到停车时长的计算，采用 `Duration` 计算停车时间，并用 `Math.ceil()` 向上取整来计算费用。

通过这样的设计思路，我们能够创建一个功能完整、并发安全、可扩展的停车场管理系统。
```java
package top.ian.es.park;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:19
 */
public class Vehicle {

    enum VehicleType {
        SMALL, TRUCK
    }

    private String licensePlate;
    private VehicleType vehicleType;

    public Vehicle(String licensePlate, VehicleType vehicleType) {
        this.licensePlate = licensePlate;
        this.vehicleType = vehicleType;
    }

    public String getLicensePlate() {
        return licensePlate;
    }

    public VehicleType getVehicleType() {
        return vehicleType;
    }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:20
 */
public class ParkingSpace {

    enum SpaceType {
        SMALL, TRUCK
    }

    private Vehicle currentVehicle;
    private SpaceType spaceType;
    private boolean isOccupied;

    public ParkingSpace(SpaceType spaceType) {
        this.spaceType = spaceType;
        this.isOccupied = false;
    }

    public boolean isOccupied() {
        return isOccupied;
    }

    public SpaceType getSpaceType() {
        return spaceType;
    }

    public void occupy(Vehicle vehicle) {
        this.currentVehicle = vehicle;
        this.isOccupied = true;
    }

    public void release() {
        this.currentVehicle = null;
        this.isOccupied = false;
    }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:20
 */
public class ParkingTicket {

   private ParkingSpace parkingSpace;
   private Vehicle vehicle;
   private LocalDateTime entryTime;

   public ParkingTicket(ParkingSpace parkingSpace, Vehicle vehicle) {
      this.parkingSpace = parkingSpace;
      this.vehicle = vehicle;
      this.entryTime = LocalDateTime.now();
   }

   public ParkingSpace getParkingSpace() {
      return parkingSpace;
   }

   public Vehicle getVehicle() {
      return vehicle;
   }

   public LocalDateTime getEntryTime() {
      return entryTime;
   }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:34
 */
public class ParkLot {

   private List<ParkingSpace> spaces;
   private List<ParkingTicket> tickets;
   private Lock lock;
   private double totalRevenue;

   public ParkLot(List<ParkingSpace> spaces) {
      this.spaces = spaces;
      this.tickets = new ArrayList<>();
      this.lock = new ReentrantLock();
      this.totalRevenue = 0.0;
   }

   public ParkingTicket vehicleEnters(Vehicle vehicle) {
      lock.lock();
      try {
         ParkingSpace space = findAvailableSpace(vehicle);
         if (space != null) {
            space.occupy(vehicle);
            ParkingTicket parkingTicket = new ParkingTicket(space, vehicle);
            tickets.add(parkingTicket);
            System.out.println("Vehicle " + vehicle.getLicensePlate() + " parked in space for "
                    + vehicle.getVehicleType());
            return parkingTicket;
         } else {
            System.out.println("out of spaces");
            return null;
         }
      } finally {
         lock.unlock();
      }
   }

   public double vehicleExit(ParkingTicket parkingTicket) {
      lock.lock();
      try {
         tickets.remove(parkingTicket);
         parkingTicket.getParkingSpace().release();
         double fee = calculateFee(parkingTicket);
         totalRevenue += fee;
         System.out.println(
                 "Vehicle " + parkingTicket.getVehicle().getLicensePlate() + " exited. Fee: "
                         + fee);
         return fee;
      } finally {
         lock.unlock();
      }
   }

   private double calculateFee(ParkingTicket parkingTicket) {
      Vehicle vehicle = parkingTicket.getVehicle();
      LocalDateTime entryTime = parkingTicket.getEntryTime();
      LocalDateTime exitTime = LocalDateTime.now().plusHours(3);

      Duration between = Duration.between(entryTime, exitTime);
      long minutes = between.toMinutes();

      long hours = (long) Math.ceil(minutes / 60);
      System.out.println("hours：" + hours);
      if (vehicle.getVehicleType() == VehicleType.SMALL) {
         return Math.min(hours * 5, 60);
      } else {
         return Math.min(hours * 10, 120);
      }
   }

   public void printAvailableSpaces() {
      long smallSpaces = spaces.stream()
              .filter(s -> !s.isOccupied() && s.getSpaceType() == SpaceType.SMALL).count();
      long truckSpaces = spaces.stream()
              .filter(s -> !s.isOccupied() && s.getSpaceType() == SpaceType.TRUCK).count();

      System.out.println("Available small spaces: " + smallSpaces);
      System.out.println("Available truck spaces: " + truckSpaces);
   }

   private ParkingSpace findAvailableSpace(Vehicle vehicle) {
      ParkingSpace.SpaceType type =
              vehicle.getVehicleType() == VehicleType.SMALL ? SpaceType.SMALL : SpaceType.TRUCK;
      ParkingSpace space = spaces.stream()
              .filter(s -> !s.isOccupied() && s.getSpaceType() == type).findFirst().orElse(null);
      return space;
   }

   public double getTotalRevenue() {
      return totalRevenue;
   }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 13:46
 */
public class ParkingSystem {

   public static void main(String[] args) throws InterruptedException {
      List<ParkingSpace> spaces = new ArrayList<>();
      for (int i = 0; i < 5; i++) {
         spaces.add(new ParkingSpace(ParkingSpace.SpaceType.SMALL));  // 5个小车位
         spaces.add(new ParkingSpace(ParkingSpace.SpaceType.TRUCK));  // 5个货车位
      }

      ParkLot parkLot = new ParkLot(spaces);

      // 模拟车辆进入
      Vehicle car1 = new Vehicle("CAR-123", Vehicle.VehicleType.SMALL);
      Vehicle truck1 = new Vehicle("TRUCK-456", Vehicle.VehicleType.TRUCK);
      Vehicle car2 = new Vehicle("CAR-789", Vehicle.VehicleType.SMALL);

      ParkingTicket ticket1 = parkLot.vehicleEnters(car1);
      ParkingTicket ticket2 = parkLot.vehicleEnters(truck1);
      ParkingTicket ticket3 = parkLot.vehicleEnters(car2);

      parkLot.printAvailableSpaces();

      // 模拟停车一段时间后车辆离开
      Thread.sleep(2000);  // 模拟停车2秒

      parkLot.vehicleExit(ticket1);
      parkLot.vehicleExit(ticket2);

      parkLot.printAvailableSpaces();

      // 打印总收入
      System.out.println("Total revenue: " + parkLot.getTotalRevenue());
   }
}
```
