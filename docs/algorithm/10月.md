# 10月（编程题、多线程、贪心、动规、排序）
## 10月22日
### [206. Reverse Linked List](https://leetcode.cn/problems/reverse-linked-list)
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }

        return pre;
    }
}
```
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```
## 10月20日（Linked List）
### [92. Reverse Linked List II](https://leetcode.cn/problems/reverse-linked-list-ii?envType=study-plan-v2&envId=top-interview-150)
```java

```
### [21. Merge Two Sorted Lists](https://leetcode.cn/problems/merge-two-sorted-lists?envType=study-plan-v2&envId=top-interview-150)
```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode();
        ListNode cur = dummy;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                cur.next = list1;
                list1 = list1.next;
            }else{
                cur.next = list2;
                list2 = list2.next;
            }
            cur = cur.next;
        }

        while(list1 != null){
            cur.next = list1;
            cur = cur.next;
            list1 = list1.next;
        }

        while(list2 != null){
            cur.next = list2;
            cur = cur.next;
            list2 = list2.next;
        }
        return dummy.next;
    }
}
```
### [2. Add Two Numbers](https://leetcode.cn/problems/add-two-numbers?envType=study-plan-v2&envId=top-interview-150)
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode();
        ListNode cur = dummy;
        int carry = 0;
        while(l1 != null || l2 != null || carry != 0){
            if(l1 != null) carry += l1.val;
            if(l2 != null) carry += l2.val;
            cur = cur.next = new ListNode(carry % 10);
            carry /= 10;
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        return dummy.next;
    }
}
```
## 10月9日
### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&envId=top-100-liked)
```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;

        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                tail.next = list1;
                list1 = list1.next;
            }else{
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }

        
        while(list1 != null){
            tail.next = list1;
            list1 = list1.next;
            tail = tail.next;
        }
        
        while(list2 != null){
            tail.next = list2;
            list2 = list2.next;
            tail = tail.next;
        }

        return dummy.next;
    }
}
```
### [148. 排序链表](https://leetcode.cn/problems/sort-list/?envType=study-plan-v2&envId=top-100-liked)
思路：归并排序，最后合并
```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;

        ListNode middle = getMiddle(head);
        ListNode left = head;
        ListNode right = middle.next;
        middle.next = null;

        left = sortList(left);
        right = sortList(right);

        return merge(left,right);
    }

    ListNode getMiddle(ListNode head){
        ListNode fast = head.next, slow = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    ListNode merge(ListNode node1,ListNode node2){
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;

        while(node1 != null && node2 != null){
            if(node1.val < node2.val){
                tail.next = node1;
                node1 = node1.next;
            }else{
                tail.next = node2;
                node2 = node2.next;
            }
            tail = tail.next;
        }

        if(node1 != null){
            tail.next = node1;
        }else{
            tail.next = node2;
        }

        return dummy.next;
    }
}
```
### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)
思路：dfs遍历，将已添加的岛屿标记为水
```java
class Solution {
    public int numIslands(char[][] grid) {
        int cout = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length;j++){
                if(grid[i][j] == '1'){
                    cout++;
                    dfs(grid,i,j);
                }
            }
        }
        return cout;
    }

    void dfs(char[][] grid,int i,int j){
        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }
}
```
### [LCR 103. 零钱兑换](https://leetcode.cn/problems/gaM7Ch/description/)
思路：dp
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;
        for(int i = 1; i <= amount;i++){
            for(int coin : coins){
                if(i >= coin){
                    dp[i] = Math.min(dp[i],dp[i-coin] + 1);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```
### [LCR 074. 合并区间](https://leetcode.cn/problems/SsGoHC/description/)
思路：先排序
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return new int[0][];
        Arrays.sort(intervals,(a,b) -> a[0]-b[0]);
        List<int[]> ans = new ArrayList<>();
        int[] cur = intervals[0];
        ans.add(cur);
        for(int[] interval : intervals){
            if(cur[1] >= interval[0]){
                cur[1] = Math.max(cur[1],interval[1]);
            }else{
                cur = interval;
                ans.add(cur);
            }
        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```
### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)
思路：双指针
```java
class Solution {
   public int maxArea(int[] height) {
      int left = 0,rigth = height.length-1;
      int ans = 0;
      while(left < rigth){
         ans = Math.max(ans,(rigth - left) * Math.min(height[left],height[rigth]));
         if(height[left] < height[rigth]){
            left++;
         }else{
            rigth--;
         }
      }
      return ans;
   }
}
```
### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/description/)
思路：二维dp，先初始化边界，再根据状态转移
```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[grid.length][grid[0].length];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m;i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int j = 1; j < n;j++) dp[0][j] = dp[0][j-1] + grid[0][j];
        for(int i = 1; i < m;i++){
            for(int j = 1; j < n;j++){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        } 
        return dp[m-1][n-1];
    }
}
```
### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/description/)
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(),n = text2.length();
        int[][] dp = new int[m+1][n+1];
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```
### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
思路：滑动窗口，通过HashSet判断是否有重复
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(),maxLen = 0;
        int left = 0;
        Set<Character> set = new HashSet<>();
        for(int rigth = 0; rigth < n; rigth++){
            while(set.contains(s.charAt(rigth))){
                set.remove(s.charAt(left++));
            }
            set.add(s.charAt(rigth));
            maxLen = Math.max(maxLen,rigth-left+1);
        }

        return maxLen;
    }
}
```
## 10月8日（二叉树）
### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)
思路：用队列FIFO，通过当前队列长度维护层级关系
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            List<Integer> cur = new ArrayList<>();
            while(len > 0){
                TreeNode node = queue.poll();
                cur.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
                len--;
            }
            ans.add(cur);
        }

        return ans;
    }
}
```
### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/?envType=problem-list-v2&envId=binary-tree)
思路：Collection.reverse(ans)
```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            List<Integer> cur = new ArrayList<>();
            while(len > 0){
                TreeNode node = queue.poll();
                cur.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
                len--;
            }

            ans.add(0,cur);
        }

        return ans;
    }
}
```
## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=problem-list-v2&envId=binary-tree)
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root != null || !stack.isEmpty()){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            ans.add(root.val);
            root = root.right;
        }

        return ans;
    }
}
```
## [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/?envType=problem-list-v2&envId=binary-tree)
记录：10.8 * 1、10.9 * 1、
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            ans.add(node.val);
            if(node.right != null) stack.push(node.right);
            if(node.left != null) stack.push(node.left);
        }

        return ans;
    }
}
```
## [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/?envType=problem-list-v2&envId=binary-tree)
```java
// 递归
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(root,ans);
        return ans;
    }

    void dfs(TreeNode root,List<Integer> list){
        if(root == null) return;
        dfs(root.left,list);
        dfs(root.right,list);
        list.add(root.val);
    }
}

// 迭代
class Solution {
   public List<Integer> postorderTraversal(TreeNode root) {
      List<Integer> ans = new ArrayList<>();
      Deque<TreeNode> stack = new ArrayDeque<>();
      TreeNode pre = null;
      while(root != null || !stack.isEmpty()){
         while(root != null){
            stack.push(root);
            root = root.left;
         }
         root = stack.pop();
         if(root.right == null || pre == root.right){
            ans.add(root.val);
            pre = root;
            root = null;
         }else{
            stack.push(root);
            root = root.right;
         }

      }
      return ans;
   }
}
```
### [LCR 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(),n = text2.length();
        int[][] dp = new int[m+1][n+1];
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }

        return dp[m][n];
    }
}
```
## 10月7日（美团社招笔试）
### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/)
思路：动规+回溯dfs
```java
class Solution {
    public List<List<String>> partition(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();
        boolean[][] f = new boolean[n][n];
        for(int j = 0; j < n; j++){
            for(int i = j; i >= 0; i--){
                if(i == j){
                    f[i][j] = true;
                }else{
                    if(j - i + 1 == 2){
                        f[i][j] = cs[i] == cs[j];
                    }else{
                        f[i][j] = cs[i] == cs[j] && f[i+1][j-1];
                    }
                }
            }
        }

        List<List<String>> ans = new ArrayList<>();
        List<String> cur = new ArrayList<>();
        dfs(s,0,ans,cur,f);
        return ans;
    }

    void dfs(String s, int u,List<List<String>> ans,List<String> cur,boolean[][] f){
        int n = s.length();
        if(n == u) ans.add(new ArrayList<>(cur));
        for(int i = u; i < n; i++){
            if(f[u][i]){
                cur.add(s.substring(u,i+1));
                dfs(s,i+1,ans,cur,f);
                cur.remove(cur.size()-1);
            }
        }
    }
}
```
### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/description/)
思路：回溯，`for(int j = idx; j <= i; j++) t = t * 10 + (cs[j] - '0');`char[] 转 int 小技巧
```java
class Solution {
    List<String> ans = new ArrayList<>();
    char[] cs;
    public List<String> restoreIpAddresses(String s) {
        cs = s.toCharArray();
        dfs(0,cs.length,new ArrayList<>());
        return ans;
    }

    void dfs(int idx,int n,List<Integer> cur){
        if(cur.size() > 4) return;
        if(idx == n){
            if(cur.size() == 4){
                StringBuilder sb = new StringBuilder();
                for(int i = 0; i<4;i++) sb.append(cur.get(i)).append(".");
                ans.add(sb.substring(0,sb.length()-1));
            }
        }else{
            for(int i = idx; i < n; i++){
                int t = 0;
                for(int j = idx; j <= i; j++) t = t * 10 + (cs[j] - '0');
                if(cs[idx] == '0' && i != idx) break;
                if(t > 255) break;
                cur.add(t);
                dfs(i + 1,n,cur);
                cur.remove(cur.size()-1);
            }
        }
    }
}
```
### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)
思路：哈希表记录
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode cur = head;
        Set<ListNode> set = new HashSet<>();
        while(cur != null){
            if(set.contains(cur)){
                return cur;
            }else{
                set.add(cur);
            }

            cur = cur.next;
        }
        return null;
    }
}
```
思路：快慢指针
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;
        ListNode fast = head,slow = head;
        while(fast != null){
            slow = slow.next;
            if(fast.next != null){
                fast = fast.next.next;
            }else{
                return null;
            }

            if(fast == slow){
                ListNode prt = head;
                while(prt != slow){
                    prt = prt.next;
                    slow = slow.next;
                }
                return prt;
            }
        }

        return null;
    }
}
```
## 10月6日（数组、链表）
### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked)
```java
class Solution {
   public void rotate(int[] nums, int k) {
      int n = nums.length;
      int[] newArr = new int[n];
      for(int i = 0; i < n; i++){
         newArr[(i+k) % n] = nums[i];
      }

      System.arraycopy(newArr,0,nums,0,n);
   }
}
```
### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)
思路：先排序，再遍历合并
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0] - b[0];
            }
        });

        List<int[]> ans = new ArrayList<>();
        for(int i =0; i < intervals.length; i++){
            int l = intervals[i][0];
            int r = intervals[i][1];
            if(ans.size() == 0 || l > ans.get(ans.size()-1)[1]){
                ans.add(new int[]{l,r});
            }else{
                ans.get(ans.size()-1)[1] = Math.max(ans.get(ans.size()-1)[1],r);
            }
        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```
### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&envId=top-100-liked)
思路：线性dp
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        for(int i = 1; i < n; i++){
            if(dp[i-1] > 0){
                dp[i] = dp[i-1] + nums[i];
            }else{
                dp[i] = nums[i];
            }
        }

        int res = dp[0];
        for(int i = 1; i<n;i++){
            res = Math.max(res,dp[i]);
        }

        return res;
    }
}
```
进一步优化
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0,ans = nums[0];
        for(int i : nums){
            pre = Math.max(pre + i,i);
            ans = Math.max(ans,pre);
        }
        return ans;
    }
}
```
### [872. 叶子相似的树](https://leetcode.cn/problems/leaf-similar-trees/description/)
思路：list保存，dfs遍历
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        dfs(root1,list1);
        dfs(root2,list2);
        if(list1.size() != list2.size()) return false;
        return list1.equals(list2);
    }

    void dfs(TreeNode root,List<Integer> list){
        if(root == null) return;
        if(root.left == null && root.right == null){
            list.add(root.val);
        }
        dfs(root.left,list);
        dfs(root.right,list);
    }
}
```
### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)
思路：比起链表复制多了一个random，通过map保存原链表node和新链表node映射关系
```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        Node dummy = new Node(-10001),cur = dummy;
        Node t = head;
        Map<Node,Node> map = new HashMap<>();
        while(head != null){
            Node node = new Node(head.val);
            map.put(head,node);
            cur.next = node;
            cur = cur.next;head = head.next;
        }

        cur = dummy.next;head = t;
        while(cur != null){
            cur.random = map.get(head.random);
            cur = cur.next;head = head.next;
        }

        return dummy.next;
    }
}
```
### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)
思路：map记录，双向链表用来维护使用频率，访问过的node放到head，tail则是最不经常访问的，实际双端队列也可以实现，只不过双向链表在头尾插入删除 O（1），实际也更好实现
```java
class LRUCache {
    class DLinkedNode{
        private int key;
        private int value;
        public DLinkedNode next;
        public DLinkedNode pre;
        public DLinkedNode(){}
        public DLinkedNode(int key,int value){
            this.key = key;
            this.value = value;
        }
    }

    private Map<Integer,DLinkedNode> cache = new HashMap<>();
    private int size;
    private int capacity;
    private DLinkedNode head;
    private DLinkedNode tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        this.head = new DLinkedNode();
        this.tail = new DLinkedNode();
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if(node != null){
            moveToHead(node);
            return node.value;
        }else{
            return -1;
        }
    }
    
    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if(node != null){
            node.value = value;
            moveToHead(node);
        }else{
            node = new DLinkedNode(key,value);
            size++;
            cache.put(key,node);
            addToHead(node);
            if(size > capacity){
               DLinkedNode tail = removeTail();
               cache.remove(tail.key);
               size--;
            }
        }
    }

    private void moveToHead(DLinkedNode node){
        removeNode(node);
        addToHead(node);
    }

    private void addToHead(DLinkedNode node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node){
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    private DLinkedNode removeTail(){
        DLinkedNode node = tail.pre;
        removeNode(node);
        return node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
## 10月4日（二叉树、多线程）
### [690. 员工的重要性](https://leetcode.cn/problems/employee-importance/description/)
思路：类似多叉树的结构，dfs遍历
```java
/*
// Definition for Employee.
class Employee {
    public int id;
    public int importance;
    public List<Integer> subordinates;
};
*/

class Solution {
    public int getImportance(List<Employee> employees, int id) {
        return dfs(employees,id);
    }

    private int dfs(List<Employee> employees,int id){
        Employee employee = employees.stream()
                                .filter(e -> e.id == id).findFirst().orElse(null);
        
        int sum = 0;
        if(employee != null){
            sum += employee.importance;
            if(employee.subordinates.size() > 0){
                for(Integer i : employee.subordinates){
                    sum += dfs(employees,i);
                }
            }
        }
        return sum;
    }
}
```
思路：通过map优化遍历查找，执行由 15 ms 提升到 5 ms
```java
/*
// Definition for Employee.
class Employee {
    public int id;
    public int importance;
    public List<Integer> subordinates;
};
*/

class Solution {
    Map<Integer,Employee> map = new HashMap<>();
    public int getImportance(List<Employee> employees, int id) {
        int n = employees.size();
        for(int i = 0; i < n; i++){
            map.put(employees.get(i).id,employees.get(i));
        }

        return dfs(id);
    }

    int dfs(int id){
        Employee master = map.get(id);
        int ans = master.importance;
        for(Integer subId : master.subordinates){
            Employee employee = map.get(subId);
            ans += employee.importance;
            for(Integer sub : employee.subordinates){
                ans += dfs(sub);
            }
        }

        return ans;
    }
}
```
### [897. 递增顺序搜索树](https://leetcode.cn/problems/increasing-order-search-tree/description/)
思路：dfs中序遍历，list保存中序遍历节点，然后再构造树
递归：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<TreeNode> list = new ArrayList<>();
    public TreeNode increasingBST(TreeNode root) {
        dfs(root);
        TreeNode dummy = new TreeNode(-1);
        TreeNode cur = dummy;
        for(TreeNode node : list){
            cur.right = node;
            node.left = null;
            cur = node;
        }
        return dummy.right;
    }

    private void dfs(TreeNode root){
        if(root == null) return;
        dfs(root.left);
        list.add(root);
        dfs(root.right);
    }
}
```
迭代：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        List<TreeNode> list = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root != null ||!stack.isEmpty()){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            list.add(root);
            root = root.right;
        }

        TreeNode dummy = new TreeNode(-1);
        TreeNode cur = dummy;
        for(TreeNode node : list){
            cur.right = node;
            node.left = null;
            cur = node;
        }

        return dummy.right;
    }
}
```
## 10月3日（快排、归并、菜鸟笔试）
### 快排
快速排序通过选取一个基准值（pivot），将待排序数组划分为两部分：一部分的元素都小于基准值，另一部分的元素都大于基准值。然后对这两部分递归进行排序。
```java
package top.ian.es;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/2 13:04
 */
public class QuickSort {

    public static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }

    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }

        swap(arr, i + 1, right);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {9, 7, 5, 11, 12, 2, 14, 3, 10, 6};
        quickSort(arr, 0, arr.length - 1);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```
### 归并
```java
package top.ian.es;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/2 13:40
 */
public class MergeSort {

    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        while (j <= right) {
            temp[k++] = arr[j++];
        }

        for (k = 0; k < temp.length; k++) {
            arr[left + k] = temp[k];
        }
    }

    public static void main(String[] args) {
        int[] arr = {9, 7, 5, 11, 12, 2, 14, 3, 10, 6};
        mergeSort(arr, 0, arr.length - 1);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }

}
```
### 菜鸟笔试
1. 编程实现：线程A向队列Q中不停写入数据，线程B从队列Q中不停读取数据（只要Q中有数据）。
```java
/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 1:29
 */
public class ThreadTest {

    private static BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);

    public static void main(String[] args) {
        Thread a = new Thread(() -> {
            int i = 0;
            while (true) {
                try {
                    queue.put(i);
                    System.out.println("a：" + i);
                    i++;
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        Thread b = new Thread(() -> {
            while (true) {
                Integer i = null;
                try {
                    i = queue.take();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("b：" + i);
            }
        });

        a.start();
        b.start();
    }
}
```
2. 假如一个学校有x名学生，对全校同学进行一次测验，总分750分，现在需要对全校同学的分数进行分段统计，每y分为1个分数段，
   要求：用一条SQL语句统计出每个分数段有多少人。(y>=1, y<=750)
```sql
select 
    CONCAT(FLOOR(score / @y) * @y,'-',FLOOR(scor / @y) * @y + @y -1) AS score_range,
    COUNT(*) AS student_count
FROM
    student
GROUP BY 
    FLOOR(score / @y)
ORDER BY 
    FLOOR(score / @y);
```
3. 某停车场(Parklot)有停车位(ParkingSpace)若干：
   有多个入口和多个出口，入口完成扫描计时，出口完成结账及车位释放。
   停车位包含两类：货车位和小车位，货车按每小时10元计价，每天最高累计120元，小车位按每小时5元计价，每天最高累计60元。
   请注意提示剩余车位信息。
   为该停车场设计一个管理系统，还原该场景，功能包括：
   （1）车辆进入处理；
   （2）车辆离开处理；
   （3）计算当日停车场缴费总金额、单个车辆离场缴费额。
   (请考虑并发等相关的实际问题)
   设计停车场管理系统时，我们需要将题目中的实际需求转化为合理的设计思路和技术实现。这个过程可以通过分析问题的各个部分，并结合面向对象编程（OOP）和并发处理的知识来进行。下面是设计思路的形成过程，以及如何一步步将需求转化为系统设计：

### 1. **明确需求**
题目要求包括以下几个功能：
- **车辆进入处理**：车辆进入停车场后，需要找到一个可用的车位，记录进入时间。
- **车辆离开处理**：车辆离开时需要释放车位，并计算停车费用。
- **计算单车缴费**：根据停车时长和车辆类型计算缴费（货车和小车不同）。
- **计算总收入**：计算当日停车场的总收入。
- **剩余车位提示**：需要实时提示停车场中剩余的车位数量。
- **并发处理**：多个入口和出口同时操作，因此需要处理并发，保证系统数据一致性。

### 2. **分析实体与功能**
根据需求，系统中有多个核心实体和功能可以提取出来：
- **车辆（Vehicle）**：每辆车有不同的类型（货车或小车），车辆有车牌号等标识信息。
- **停车位（ParkingSpace）**：停车位分为货车位和小车位，每个车位有不同的占用状态。
- **停车场（ParkLot）**：管理多个车位、车辆进出、以及收费的核心类。它需要知道所有停车位的状态。
- **停车票（ParkingTicket）**：记录车辆进入停车场的时间和停放的车位，便于结算。
- **并发性**：停车场存在多个入口和出口，车辆进出需要并发处理，防止不同线程对停车位状态的冲突。

### 3. **确定设计思路（面向对象设计）**
根据需求，我们可以采用**面向对象编程（OOP）**的设计方法，将每一个实体和功能抽象为类，并让类之间合理交互：

#### 核心类设计：
1. **`Vehicle` 类**：抽象出车辆对象，车辆具有类型（货车、小车）和车牌号。
   - **属性**：车牌号、车辆类型。
   - **行为**：车辆可以进入和离开停车场。

2. **`ParkingSpace` 类**：抽象出停车位，分为小车位和货车位。
   - **属性**：车位类型（小车位、货车位）、是否被占用、关联的车辆。
   - **行为**：停车位可以被占用或释放。

3. **`ParkingTicket` 类**：用于记录停车信息，如进入时间、停车位信息等。
   - **属性**：车辆、停车位、进入时间。
   - **行为**：记录停车时间。

4. **`ParkLot` 类**：停车场类，是整个系统的管理类，管理停车位的分配和回收，计算停车费，统计总收入。
   - **属性**：所有停车位、所有活动的停车票、总收入。
   - **行为**：
      - **车辆进入**：找到空车位，并生成停车票。
      - **车辆离开**：根据停车票计算费用，释放车位，统计收入。
      - **查看剩余车位**：打印剩余车位数。
      - **并发处理**：使用 `Lock` 确保多个线程操作停车位时的数据一致性。

#### 并发设计：
为了处理多个线程（入口和出口）同时操作车位，必须确保线程安全。可以通过以下方式：
- 使用 `ReentrantLock` 来确保停车位操作的原子性，避免多线程同时修改同一停车位的状态。
- 每次进入停车场时加锁操作，确保只有一个线程可以修改停车位的占用状态。

### 4. **详细设计细化**
#### 车辆进入：
- 车辆进入时，首先判断是货车还是小车，然后寻找相应类型的空车位。
- 一旦找到空车位，将该车位标记为占用，并生成停车票。
- 在并发情况下，通过 `Lock` 来确保同一时刻只能有一个线程为车分配车位。

#### 车辆离开：
- 车辆离开时，基于停车票中的进入时间计算停车时长。
- 根据停车时长和车辆类型计算费用。
- 将车位标记为可用，更新停车场的总收入。

#### 费用计算：
- 通过 `Duration` 计算车辆的停车时长，然后使用 `Math.ceil()` 实现向上取整的计费方式。
- 货车按每小时 10 元，封顶 120 元；小车按每小时 5 元，封顶 60 元。

### 5. **实现系统扩展性**
- **可扩展性**：如果以后需要支持其他类型的车位或收费规则，可以在现有的结构上扩展，例如增加更多的 `VehicleType`，修改 `ParkingSpace` 的属性，或在 `ParkLot` 中增加更多的计算规则。
- **线程安全性**：通过锁机制保证了系统在并发环境下的安全性，可以保证多个入口和出口不会出现车位分配的冲突。
- **灵活性**：系统设计成模块化，便于维护和扩展。

### 总结：设计思路的演进
1. **需求分析**：首先了解停车场的核心功能，包括车辆进出、车位分配、收费计算等。
2. **面向对象分析**：提取问题中的实体，抽象成类，明确每个类的职责。
3. **并发问题解决**：为了解决多线程并发访问停车位的问题，使用 `Lock` 保证线程安全。
4. **算法细化**：具体到停车时长的计算，采用 `Duration` 计算停车时间，并用 `Math.ceil()` 向上取整来计算费用。

通过这样的设计思路，我们能够创建一个功能完整、并发安全、可扩展的停车场管理系统。
```java
package top.ian.es.park;

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:19
 */
public class Vehicle {

    enum VehicleType {
        SMALL, TRUCK
    }

    private String licensePlate;
    private VehicleType vehicleType;

    public Vehicle(String licensePlate, VehicleType vehicleType) {
        this.licensePlate = licensePlate;
        this.vehicleType = vehicleType;
    }

    public String getLicensePlate() {
        return licensePlate;
    }

    public VehicleType getVehicleType() {
        return vehicleType;
    }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:20
 */
public class ParkingSpace {

    enum SpaceType {
        SMALL, TRUCK
    }

    private Vehicle currentVehicle;
    private SpaceType spaceType;
    private boolean isOccupied;

    public ParkingSpace(SpaceType spaceType) {
        this.spaceType = spaceType;
        this.isOccupied = false;
    }

    public boolean isOccupied() {
        return isOccupied;
    }

    public SpaceType getSpaceType() {
        return spaceType;
    }

    public void occupy(Vehicle vehicle) {
        this.currentVehicle = vehicle;
        this.isOccupied = true;
    }

    public void release() {
        this.currentVehicle = null;
        this.isOccupied = false;
    }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:20
 */
public class ParkingTicket {

   private ParkingSpace parkingSpace;
   private Vehicle vehicle;
   private LocalDateTime entryTime;

   public ParkingTicket(ParkingSpace parkingSpace, Vehicle vehicle) {
      this.parkingSpace = parkingSpace;
      this.vehicle = vehicle;
      this.entryTime = LocalDateTime.now();
   }

   public ParkingSpace getParkingSpace() {
      return parkingSpace;
   }

   public Vehicle getVehicle() {
      return vehicle;
   }

   public LocalDateTime getEntryTime() {
      return entryTime;
   }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 12:34
 */
public class ParkLot {

   private List<ParkingSpace> spaces;
   private List<ParkingTicket> tickets;
   private Lock lock;
   private double totalRevenue;

   public ParkLot(List<ParkingSpace> spaces) {
      this.spaces = spaces;
      this.tickets = new ArrayList<>();
      this.lock = new ReentrantLock();
      this.totalRevenue = 0.0;
   }

   public ParkingTicket vehicleEnters(Vehicle vehicle) {
      lock.lock();
      try {
         ParkingSpace space = findAvailableSpace(vehicle);
         if (space != null) {
            space.occupy(vehicle);
            ParkingTicket parkingTicket = new ParkingTicket(space, vehicle);
            tickets.add(parkingTicket);
            System.out.println("Vehicle " + vehicle.getLicensePlate() + " parked in space for "
                    + vehicle.getVehicleType());
            return parkingTicket;
         } else {
            System.out.println("out of spaces");
            return null;
         }
      } finally {
         lock.unlock();
      }
   }

   public double vehicleExit(ParkingTicket parkingTicket) {
      lock.lock();
      try {
         tickets.remove(parkingTicket);
         parkingTicket.getParkingSpace().release();
         double fee = calculateFee(parkingTicket);
         totalRevenue += fee;
         System.out.println(
                 "Vehicle " + parkingTicket.getVehicle().getLicensePlate() + " exited. Fee: "
                         + fee);
         return fee;
      } finally {
         lock.unlock();
      }
   }

   private double calculateFee(ParkingTicket parkingTicket) {
      Vehicle vehicle = parkingTicket.getVehicle();
      LocalDateTime entryTime = parkingTicket.getEntryTime();
      LocalDateTime exitTime = LocalDateTime.now().plusHours(3);

      Duration between = Duration.between(entryTime, exitTime);
      long minutes = between.toMinutes();

      long hours = (long) Math.ceil(minutes / 60);
      System.out.println("hours：" + hours);
      if (vehicle.getVehicleType() == VehicleType.SMALL) {
         return Math.min(hours * 5, 60);
      } else {
         return Math.min(hours * 10, 120);
      }
   }

   public void printAvailableSpaces() {
      long smallSpaces = spaces.stream()
              .filter(s -> !s.isOccupied() && s.getSpaceType() == SpaceType.SMALL).count();
      long truckSpaces = spaces.stream()
              .filter(s -> !s.isOccupied() && s.getSpaceType() == SpaceType.TRUCK).count();

      System.out.println("Available small spaces: " + smallSpaces);
      System.out.println("Available truck spaces: " + truckSpaces);
   }

   private ParkingSpace findAvailableSpace(Vehicle vehicle) {
      ParkingSpace.SpaceType type =
              vehicle.getVehicleType() == VehicleType.SMALL ? SpaceType.SMALL : SpaceType.TRUCK;
      ParkingSpace space = spaces.stream()
              .filter(s -> !s.isOccupied() && s.getSpaceType() == type).findFirst().orElse(null);
      return space;
   }

   public double getTotalRevenue() {
      return totalRevenue;
   }
}

/**
 * @Author: Ian
 * @Mail: 17326084822@163.com
 * @Date: 2024/10/4 13:46
 */
public class ParkingSystem {

   public static void main(String[] args) throws InterruptedException {
      List<ParkingSpace> spaces = new ArrayList<>();
      for (int i = 0; i < 5; i++) {
         spaces.add(new ParkingSpace(ParkingSpace.SpaceType.SMALL));  // 5个小车位
         spaces.add(new ParkingSpace(ParkingSpace.SpaceType.TRUCK));  // 5个货车位
      }

      ParkLot parkLot = new ParkLot(spaces);

      // 模拟车辆进入
      Vehicle car1 = new Vehicle("CAR-123", Vehicle.VehicleType.SMALL);
      Vehicle truck1 = new Vehicle("TRUCK-456", Vehicle.VehicleType.TRUCK);
      Vehicle car2 = new Vehicle("CAR-789", Vehicle.VehicleType.SMALL);

      ParkingTicket ticket1 = parkLot.vehicleEnters(car1);
      ParkingTicket ticket2 = parkLot.vehicleEnters(truck1);
      ParkingTicket ticket3 = parkLot.vehicleEnters(car2);

      parkLot.printAvailableSpaces();

      // 模拟停车一段时间后车辆离开
      Thread.sleep(2000);  // 模拟停车2秒

      parkLot.vehicleExit(ticket1);
      parkLot.vehicleExit(ticket2);

      parkLot.printAvailableSpaces();

      // 打印总收入
      System.out.println("Total revenue: " + parkLot.getTotalRevenue());
   }
}
```
