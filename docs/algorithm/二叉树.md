# 分治法
## [04. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
<!-- tabs:start -->
#### **Go**
```go
func maxDepth(root *TreeNode) int {
    if root == nil{
        return 0
    }

    left := maxDepth(root.Left)
    right := maxDepth(root.Right)

    if left > right{
        return left+1
    }

    return right+1
}
```
#### **Java**
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);

        if(left > right){
            return left+1;
        }

        return right+1;
    }
}
```
<!-- tabs:end -->

## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
<!-- tabs:start -->
#### **Go**
```go
func isBalanced(root *TreeNode) bool {
    if maxDepth(root) == -1{
        return false
    }
    return true
}

func maxDepth(root *TreeNode) int{
    if root == nil{
        return 0
    }

    left := maxDepth(root.Left)
    right := maxDepth(root.Right)

    if left == -1 || right == -1 || left-right > 1 || right-left > 1{
        return -1
    }
    if left > right{
        return left+1
    }
    return right+1
}
```
#### **Java**
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(maxDepth(root) == -1){
            return false;
        }
        return true;
    }

    public int maxDepth(TreeNode root){
        if(root == null){
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);

        if(left == -1 || right == -1 || left-right>1|| right-left>1){
            return -1;
        }

        if(left > right){
            return left+1;
        }
        return right+1;
    }
}
```
<!-- tabs:end -->
## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
分治法
<!-- tabs:start -->
#### **Go**
```go
func maxPathSum(root *TreeNode) int {
    ans := -(1<<31)
    var dfs func(*TreeNode) int
    dfs = func(node *TreeNode) int{
        if node == nil{
            return 0
        }
        lVal := dfs(node.Left)
        rVal := dfs(node.Right)
        ans = max(ans,lVal+rVal+node.Val)
        return max(max(lVal,rVal)+node.Val,0)
    }
    dfs(root)
    return ans
}
```
#### **Java**
```java
class Solution {
    private int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }

    private int dfs(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        ans = Math.max(ans,left+right+root.val);
        return Math.max(Math.max(left,right)+root.val,0);
    }
}
```
<!-- tabs:end -->
## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
<!-- tabs:start -->
#### **Go**
```go
 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil{
        return root
    }
    if root == q || root == p{
        return root
    }

    left := lowestCommonAncestor(root.Left,p,q)
    right := lowestCommonAncestor(root.Right,p,q)

    if left != nil && right != nil{
        return root
    }

    if left != nil{
        return left
    }
    if right != nil{
        return right
    }
    return nil
}
```
#### **Java**
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null|| root == p || root == q){
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if(left != null && right != null){
            return root;
        }
        if(left != null){
            return left;
        }
        return right;
    }
}
```
<!-- tabs:end -->
# BFS
## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
<!-- tabs:start -->
#### **Go**
```go
func levelOrder(root *TreeNode) [][]int {
    result := make([][]int,0)
    if root == nil{
        return result
    }
    queue := make([]*TreeNode,0)
    queue = append(queue,root)
    for len(queue) > 0{
        list := make([]int,0)
        len := len(queue)
        for i := 0;i < len;i++{
            level := queue[0]
            queue = queue[1:]
            list = append(list,level.Val)
            if level.Left != nil{
                queue = append(queue,level.Left)
            }
            if level.Right != nil{
                queue = append(queue,level.Right)
            }
        }
        result = append(result,list)
    }
    return result
}
```
#### **Java**
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root == null){
            return result;
        }

        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while(queue.size()>0){
            List<Integer> list = new ArrayList<>();
            int len = queue.size();
            while(len > 0){
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                len--;
            }
            result.add(list);
        }
        return result;
    }
}
```
<!-- tabs:end -->