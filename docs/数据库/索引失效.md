# 索引失效场景
* system：系统表，少量数据，往往不需要进行磁盘IO
* const：常量连接
* eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描
* ref：非主键非唯一索引等值扫描
* range：范围扫描
* index：索引树扫描
* ALL：全表扫描(full table scan)

* Using index：表示查询可以完全通过索引来获取数据，不需要访问数据表的行（即 "索引覆盖"）。这种情况性能较好，因为只访问了索引，没有读表。
* Using index condition：表示 MySQL 只使用了索引进行部分过滤，但仍然需要读取表中的数据行。虽然通过索引进行了一定的优化，但相比完全使用索引，性能会略逊一筹。
* Extra = Using where是一个表示查询优化器正在有效利用WHERE子句的条件来优化查询执行的标志。

索引扫描和全表扫描的区别:
索引树 ， 就是会遍历聚簇索引树，底层是一颗B+树，叶子节点存储了所有的实际行数据。
全表扫描, 也是扫描的聚簇索引树，因为聚簇索引树的叶子节点中存储的就是实际数据，只要扫描遍历聚簇索引树就可以得到全表的数据了。
索引树扫描可以从树根往下 做类似的 二分查找， 时间复杂度是 o（logn）； 全表扫描 是扫描所有的 叶子节点， 时间复杂度是 o（n）；
全表扫描不仅仅需要扫描索引列，还需要扫描每个索引列中指向的实际数据，这里包含了所有的非索引列数据。
## 破坏最左匹配原则 
MySQL 的 最左匹配原则 是指在使用复合索引（即多个列组成的索引）时，查询条件中的字段必须从索引的最左边开始依次匹配，才能有效利用索引来加速查询。

1. 未满足最左匹配原则，查询条件不包括第一列，索引失效
2. 使用范围查询，范围查询后的列无法通过索引优化
## 破坏索引覆盖原则
索引覆盖：查询的字段全部在索引的字段中。
索引覆盖（Index Covering）是指一个查询所需的所有数据都可以从索引中直接获取，而不需要访问表的行本身。在使用索引进行查询时，如果索引包含了查询中所需的所有列，那么就可以实现索引覆盖。
在MySQL中，当一个索引包含了查询所需的所有字段时，数据库引擎可以直接使用这个索引来响应查询请求，而不需要回表（即不需要访问实际的表数据行）去获取数据。
索引覆盖的优点包括：
* 减少I/O操作：由于不需要访问表的数据行，因此减少了磁盘I/O操作，这对于磁盘存储的数据库来说尤其重要。
* 提高查询速度：索引通常比表数据更加紧凑，并且是经过优化的，所以使用索引覆盖可以加快查询速度。
* 减少数据访问量：数据库引擎只需要读取索引，而不需要读取整个表，这减少了数据访问量。

1. 使用了select * 破坏索引覆盖，导致索引失效，《阿里巴巴开发手册》中明确说过，查询sql中禁止使用select *
## 破坏前缀匹配原则
在 MySQL 中，前缀匹配是指使用索引在查询中匹配字符串的开头部分，这种方式可以大大提升查询的性能。

1. 破坏 模糊查询的 前缀匹配, 导致 索引失效 的一个例子： like左边包含%
## order by 排序不当
Using filesort 文件排序，通常意味着 MySQL 会将结果集加载到内存中，然后进行排序，这可能会影响查询性能，尤其是在处理大量数据时。
Using filesort 文件排序，其实文件排序的话，会有很多种情况，
比如说：根据要排序的内容大小，就有内部排序和外部排序；
如果，排序的内容比较小，那么，在内存中就可以搞定，这就是内部排序（使用快排）；
如果，要排序的内容太大，那么，就得需要通过磁盘的帮助了，这个就是外部排序（使用归并）。
还有，就是根据一行的大小来进行区分，
如果，一行的内容不是很大，那么，就整个字段读取出来进行排序，称为全字段排序；
如果，整个字段内容很大，那么，就采用rowid排序，读取rowid和该字段先进行排序，然后，再回表查找其他的内容；

1. 索引列和 ORDER BY 列不匹配：如果 ORDER BY 子句中引用的列没有被索引覆盖，MySQL 可能无法使用索引来排序，而必须进行额外的排序操作（Using filesort）。
2. 如果 WHERE 子句中的条件列和 ORDER BY 子句中的排序列不一致，且没有相应的索引，那么索引可能不会被使用。where 一个索引， order by 一个索引，创建合适的索引，确保where 字句 和  ORDER BY 子句中的列被索引覆盖。
## or 使用不当
1. or 前后有一个列不是索引，或者前后都是单独的索引不是联合索引，创建一个包含所有 OR 条件列的复合索引

将包含 OR 条件的查询拆分成多个独立的查询，然后使用 UNION 或 UNION ALL来合并结果
## 索引列上有计算或者函数
这是因为数据库的查询优化器无法对计算后的结果进行有效的索引查找

1. 索引列上有计算，导致的索引失效
2. 索引列上有函数，导致的索引失效
3. 
## 使用 not in 和 not exists 不当
## 列的对比