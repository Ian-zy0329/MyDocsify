## 为什么要⽤ Redis/为什么要⽤缓存？
主要是提升用户体验和应对更多用户，高性能和高并发
- 数据库数据保存在硬盘中，而 raids 数据保存在内存中，读取速度更快
- ⼀般像 MySQL 这类的数据库的 QPS ⼤概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后很容
  易达到 10w+，甚⾄最⾼能达到 30w+（就单机 redis 的情况，redis 集群的话会更⾼）。
  QPS（Query Per Second）：服务器每秒可以执⾏的查询次数；
  由此可⻅，直接操作缓存能够承受的数据库请求数量是远远⼤于直接访问数据库的，所以我们可以考
  虑把数据库中的部分数据转移到缓存中去，这样⽤户的⼀部分请求会直接到缓存这⾥⽽不⽤经过数据
  库。进⽽，我们也就提⾼了系统整体的并发

## Redis 常⽤的数据结构有哪些？
- 5 种基础数据结构 ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset
（有序集合）。
- 3 种特殊数据结构 ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位
置)。

## Redis 除了做缓存，还能做什么？
- 分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。
- 限流：一般是通过 Redis + Lua 脚本的方式来实现限流。如果不想自己写 Lua 脚本的话，也可以直接利用 Redisson 中的 RRateLimiter 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。
- 消息队列：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。
- 延时队列：Redisson 内置了延时队列（基于 Sorted Set 实现的）。
- 分布式 Session ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。

## 1. Redis内存回收机制
Redis 的内存回收主要由两部分组成：
- Redis过期策略：删除过期时间的key值
- Redis淘汰策略：内存使用到达maxmemory上限时触发内存淘汰数据

## 过期的数据的删除策略了解么？
1. 惰性删除 ：只会在取出 key 的时候才对数据进⾏过期检查。这样对 CPU 最友好，但是可能会
   造成太多过期 key 没有被删除。
2. 定期删除 ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期 key 操作。并且，Redis 底层会通过限制
   删除操作执⾏的时⻓和频率来减少删除操作对 CPU 时间的影响。

## Redis 内存淘汰机制
1.no-envicition：
该策略对于写请求不再提供服务，会直接返回错误，当然排除del等特殊操作，redis默认是no-envicition策略。

2.allkeys-random：
从redis中随机选取key进行淘汰

3.allkeys-lru：
使用LRU（Least Recently Used，最近最少使用）算法，从redis中选取使用最少的key进行淘汰

4.volatile-random：
从redis中设置过过期时间的key，进行随机淘汰

5.volatile-ttl：
从redis中选取即将过期的key，进行淘汰

6.volatile-lru：
使用LRU（Least Recently Used，最近最少使用）算法，从redis中设置过过期时间的key中，选取最少使用的进行淘汰

7.volatile-lfu:
使用LFU（Least Frequently Used，最不经常使用），从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉

8.allkeys-lfu:
使用LFU（Least Frequently Used，最不经常使用），从所有的键中选择某段时间之内使用频次最少的键值对清除

## Redis 内存淘汰算法
- 随机（随机算法很好理解，就是从数据库中随机淘汰一些 Keys）
- TTL（ TTL 算法就是从设置了过期时间的 Keys 中获取最早过期的 一批 Keys，然后淘汰这些 Keys）
- LRU（Least Recently Used，最近最少使用）LRU 主要是通过 Key 的最后访问时间来判定哪些 Key 更适合被淘汰
- LFU（Least Frequently Used，最不经常使用）根据数据的历史访问频率来淘汰数据

## Redis 持久化机制
- 快照（snapshotting，RDB）通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本
- 只追加⽂件（append-only file, AOF）开启 AOF 持久化后每执⾏⼀条会更改 Redis 中的数据的命令，Redis 就会将该命令写⼊到内存缓存
  server.aof_buf 中，然后再根据 appendfsync （always、everysec、no）配置来决定何时将其同步到硬盘中的 AOF ⽂件

## 什么是缓存穿透？
缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，没有经过缓存这⼀层。
- 最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。
- 缓存⽆效 key 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 Redis 中去并设置过期时间
- 布隆过滤器 把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过来，先判断⽤户
  发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端
- 接口限流

## 布隆过滤器的原理
布隆过滤器主要是为了解决海量数据的存在性问题。对于海量数据中判定某个数据是否存在且容忍轻微误差这一场景（比如缓存穿透、海量数据去重）来说，非常适合
当一个元素加入布隆过滤器中的时候，会进行如下操作：
1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组（bit 数组）中把对应下标的值置为 1。
当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作： 
1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

## 什么是缓存击穿？
缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力
有哪些解决办法？
1. 永不过期（不推荐）：设置热点数据永不过期或者过期时间比较长。
2. 提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
3. 加锁（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。

## 什么是缓存雪崩？
缓存或者有⼀些被⼤量访问数据（热点缓存）在同一时间大面积失效，后面的请求直接落在数据库上，造成数据库短时间内承受大量请求。
针对 Redis 服务不可⽤的情况：
1. Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。
2. 多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。

针对大量缓存同时失效的情况：
1. 设置随机失效时间（可选）：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。
2. 提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
3. 持久缓存策略（看情况）：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。

常见的缓存预热方式有两种：
1. 使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。
2. 使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存

